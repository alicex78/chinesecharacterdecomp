<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
  <head>
    <title>group1 [PsychoPy]</title>
    <meta charset="UTF-8">
    <link href="js/vendors//jquery-ui-1.11.4.base/jquery-ui.min.css" rel="stylesheet">

    <style>
        /* project and resource dialogs */
        label, input { display:block; padding-bottom: .5em; }
        input.text { margin-bottom:1em; width:95%; padding: .5em; }
        fieldset { padding:0; border:0; margin-top:25px; }

        /* don't display close button in the top right corner of the box */
        .no-close .ui-dialog-titlebar-close { display: none; }
    </style>
  </head>

  <body>

    <!-- dialog place holder -->
    <div id="dialogDiv"/>

    <script type="text/javascript" src="js/vendors/Math2.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-ui-1.11.4.base/jquery-ui.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery.blockUI.js" ></script>
    <script type="text/javascript" src="js/vendors/stats.min.js"></script>
    <script type="text/javascript" src="js/vendors/pixi.min.js"></script>
    <script type="text/javascript" src="js/vendors/papaparse.min.js"></script>
    <script type="text/javascript" src="js/vendors/preloadjs-0.6.2.min.js"></script>

    <script type="text/javascript" src="js/psychojs/main.js"></script>
    <script type="text/javascript" src="js/psychojs/core.js"></script>
    <script type="text/javascript" src="js/psychojs/data.js"></script>
    <script type="text/javascript" src="js/psychojs/events.js"></script>
    <script type="text/javascript" src="js/psychojs/gui.js"></script>
    <script type="text/javascript" src="js/psychojs/util.js"></script>
    <script type="text/javascript" src="js/psychojs/scheduler.js"></script>
    <script type="text/javascript" src="js/psychojs/visual.js"></script>
    <script type="text/javascript" src="js/psychojs/io.js"></script>
    <script type="text/javascript" src="js/psychojs/jamdb.js"></script>
    <script type="text/javascript" src="js/psychojs/colors.js"></script>
    <script type="text/javascript" src="js/psychojs/logging.js"></script>

    <script type='text/javascript'>
      // wait until document is ready:
      $(document).ready(function() {
        psychoJS.debug = true; //false;
        
        function setupExperiment() {
        
          // An ExperimentHandler isn't essential but helps with data saving
          thisExp = new psychoJS.data.ExperimentHandler({
              name: 'group1',
              version: '',
              extraInfo: expInfo,
              runtimeInfo: undefined,  // not yet supported by psychoJS
              originPath: undefined,  //not yet supported by psychoJS
              savePickle: true,       // not yet supported by psychoJS
              saveWideText: true,
              saveTo: 'EXPERIMENT_SERVER',
              /*dataFileName=filename*/});
        
          // setup resource manager:
          psychoJS.resourceManager.set({
                                win:win, downloadFrom:'EXPERIMENT_SERVER', projectId:undefined,
                                projectStatus:'PUBLIC', clock:new psychoJS.core.Clock()
                                });
        
          endExpNow = false; // flag for 'escape' or other condition => quit the exp
        
          // logging:
          psychoJS.logging.console.setLevel(psychoJS.logging.EXP);
          psychoJS.logging.server.set({'level':psychoJS.logging.EXP, 'saveTo':'EXPERIMENT_SERVER', 'experimentInfo': expInfo});
        
          return psychoJS.NEXT;
        }
        
        function updateInfo() {
          expInfo['date'] = psychoJS.data.getDateStr();  // add a simple timestamp
          expInfo['expName'] = expName;
        
          // store frame rate of monitor if we can measure it successfully
          expInfo['frameRate'] = win.getActualFrameRate();
          if (expInfo['frameRate'] != undefined) {
              frameDur = 1.0/Math.round(expInfo['frameRate']);
          }
          else {
              frameDur = 1.0/60.0; // couldn't get a reliable measure so guess
          }
        
          return psychoJS.NEXT;
        }
        
        function setupWin() {
          // Start Code - component code to be run before the window creation
          // Setup the Window
          win = new psychoJS.visual.Window({size:[1920, 1080],
              fullscr:true, screen:1.0,
              allowGUI:false, allowStencil:false,
              monitor:'testMonitor',
              color:[1,1,1], colorSpace:'rgb',
              blendMode:'avg',
              units:'use prefs'
              });
          return psychoJS.NEXT;
        }
        
        function experimentInit() {
          
          // Initialize components for Routine "instructions"
          instructionsClock = new psychoJS.core.Clock();
          text = new psychoJS.visual.TextStim({win : win, name : 'text',
              text : "You will first be presented with a few strings of symbols flashing on the screen very quickly. \n\nThen, decide whether the Chinese character you see is a real character or not.\n\nIf yes, press the 'Y' key as quickly as possible.\nIf no, press the 'N' key.\n\nOn each trial, you will see a fixation point, a plus sign: +. After you make your decision about the letter string and press the appropriate key, the next trial will begin.\n\nPress the spacebar to start.",
              font : 'Arial',
              pos : [0, 0], height : 0.075, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          
          // Initialize components for Routine "trial_1"
          trial_1Clock = new psychoJS.core.Clock();
          fixate_2 = new psychoJS.visual.TextStim({win : win, name : 'fixate_2',
              text : '+',
              font : 'Arial',
              pos : [0, 0], height : 0.2, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          fwd_prime_2 = new psychoJS.visual.TextStim({win : win, name : 'fwd_prime_2',
              text : '######',
              font : 'Arial',
              pos : [0, 0], height : 0.15, wrapWidth : undefined, ori:0, 
              color : 'black', colorSpace:'rgb', opacity : 1,
              depth : -1.0 
          });
          radicalprime = new psychoJS.visual.ImageStim({
              win : win, name : 'radicalprime',
              image : 'sin', mask : undefined,
              ori : 0, pos : [0, 0], size : undefined,
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : -3.0 
          });
          targetchar = new psychoJS.visual.ImageStim({
              win : win, name : 'targetchar',
              image : 'sin', mask : undefined,
              ori : 0, pos : [0, 0], size : undefined,
              color : [1,1,1], colorSpace : 'rgb', opacity : 1,
              flipHoriz : false, flipVert : false,
              texRes : 128, interpolate : true, depth : -4.0 
          });
          
          // Create some handy timers
          globalClock = new psychoJS.core.Clock();  // to track the time since experiment started
          routineTimer = new psychoJS.core.CountdownTimer();  // to track time remaining of each (non-slip) routine
          
          return psychoJS.NEXT;
        }
        
        function instructionsRoutineBegin() {
          //------Prepare to start Routine 'instructions'-------
          t = 0;
          instructionsClock.reset(); // clock
          frameN = -1;
          // update component parameters for each repeat
          start = new psychoJS.event.BuilderKeyResponse();
          // keep track of which components have finished
          instructionsComponents = [];
          instructionsComponents.push(text);
          instructionsComponents.push(start);
          for(var i = 0; i < instructionsComponents.length; ++i) {
            thisComponent = instructionsComponents[i];
            if ('status' in thisComponent) {
              thisComponent.status = psychoJS.NOT_STARTED;
            }
          }
          
          return psychoJS.NEXT;
          }
          
          function instructionsRoutineEachFrame() {
            //------Loop for each frame of Routine 'instructions'-------
            continueRoutine = true;
             // until we're told otherwise
            // get current time
            t = instructionsClock.getTime();
            frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
            // update/draw components on each frame
            
            // *text* updates
            if (t >= 0.0 && text.status === psychoJS.NOT_STARTED) {
              // keep track of start time/frame for later
              text.tStart = t;  // (not accounting for frame time here)
              text.frameNStart = frameN;  // exact frame index
              text.setAutoDraw(true);
            }
            
            // *start* updates
            if (t >= 0.0 && start.status === psychoJS.NOT_STARTED) {
              // keep track of start time/frame for later
              start.tStart = t;  // (not accounting for frame time here)
              start.frameNStart = frameN;  // exact frame index
              start.status = psychoJS.STARTED;
              // keyboard checking is just starting
              start.clock.reset();  // now t=0
              psychoJS.event.clearEvents({eventType:'keyboard'});
            }
            if (start.status == psychoJS.STARTED) {
              theseKeys = psychoJS.event.getKeys({keyList:['space']});
              
              // check for quit:
              if ("escape" in theseKeys) {
                  endExpNow = true;
              }
              if (theseKeys.length > 0) {  // at least one key was pressed
                start.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
                start.rt = start.clock.getTime();
                // a response ends the routine
                continueRoutine = false;
              }
            }
            
            // check if the Routine should terminate
            if (!continueRoutine) {  // a component has requested a forced-end of Routine
              return psychoJS.NEXT;
            }
            continueRoutine = false;// reverts to True if at least one component still running
            for(var i = 0; i < instructionsComponents.length; ++i) {
              thisComponent = instructionsComponents[i];
              if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                continueRoutine = true;
                break;
              }
            }
            // check for quit (the Esc key)
            if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
              psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
            }
            
            // refresh the screen if continuing
            if (continueRoutine) {
              return psychoJS.FLIP_REPEAT;
            }
            else {
              return psychoJS.NEXT;
            }
          }
          
          function instructionsRoutineEnd() {
            //------Ending Routine 'instructions'-------
            for (var i = 0; i < instructionsComponents.length; ++i) {
              thisComponent = instructionsComponents[i];
              if ("setAutoDraw" in thisComponent) {
                thisComponent.setAutoDraw(false);
              }
            }
            // check responses
            if (['', [], undefined].indexOf(start.keys) >= 0) {    // No response was made
                start.keys = undefined;
            }
            thisExp.addData('start.keys',start.keys);
            if (start.keys != undefined) {  // we had a response
                thisExp.addData('start.rt', start.rt)
            }
            // the Routine "instructions" was not non-slip safe, so reset the non-slip timer
            routineTimer.reset();
            return psychoJS.NEXT;
          }
          
          function trial_1RoutineBegin() {
            //------Prepare to start Routine 'trial_1'-------
            t = 0;
            trial_1Clock.reset(); // clock
            frameN = -1;
            routineTimer.add(3.560000);
            // update component parameters for each repeat
            key_resp1_2 = new psychoJS.event.BuilderKeyResponse();
            radicalprime.setImage(psychoJS.resourceManager.getResource(picture));
            targetchar.setImage(psychoJS.resourceManager.getResource(tar_picture));
            // keep track of which components have finished
            trial_1Components = [];
            trial_1Components.push(fixate_2);
            trial_1Components.push(fwd_prime_2);
            trial_1Components.push(key_resp1_2);
            trial_1Components.push(radicalprime);
            trial_1Components.push(targetchar);
            for(var i = 0; i < trial_1Components.length; ++i) {
              thisComponent = trial_1Components[i];
              if ('status' in thisComponent) {
                thisComponent.status = psychoJS.NOT_STARTED;
              }
            }
            
            return psychoJS.NEXT;
            }
            
            function trial_1RoutineEachFrame() {
              //------Loop for each frame of Routine 'trial_1'-------
              continueRoutine = true;
               // until we're told otherwise
              // get current time
              t = trial_1Clock.getTime();
              frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
              // update/draw components on each frame
              
              // *fixate_2* updates
              if (t >= 0.0 && fixate_2.status === psychoJS.NOT_STARTED) {
                // keep track of start time/frame for later
                fixate_2.tStart = t;  // (not accounting for frame time here)
                fixate_2.frameNStart = frameN;  // exact frame index
                fixate_2.setAutoDraw(true);
              }
              frameRemains = 0.0 + 1.0 - frameDur * 0.75;  // most of one frame period left
              if (fixate_2.status === psychoJS.STARTED && t >= frameRemains) {
                fixate_2.setAutoDraw(false);
              }
              
              // *fwd_prime_2* updates
              if (t >= 1 && fwd_prime_2.status === psychoJS.NOT_STARTED) {
                // keep track of start time/frame for later
                fwd_prime_2.tStart = t;  // (not accounting for frame time here)
                fwd_prime_2.frameNStart = frameN;  // exact frame index
                fwd_prime_2.setAutoDraw(true);
              }
              frameRemains = 1 + .5 - frameDur * 0.75;  // most of one frame period left
              if (fwd_prime_2.status === psychoJS.STARTED && t >= frameRemains) {
                fwd_prime_2.setAutoDraw(false);
              }
              
              // *key_resp1_2* updates
              if (t >= 1.56 && key_resp1_2.status === psychoJS.NOT_STARTED) {
                // keep track of start time/frame for later
                key_resp1_2.tStart = t;  // (not accounting for frame time here)
                key_resp1_2.frameNStart = frameN;  // exact frame index
                key_resp1_2.status = psychoJS.STARTED;
                // keyboard checking is just starting
                key_resp1_2.clock.reset();  // now t=0
                psychoJS.event.clearEvents({eventType:'keyboard'});
              }
              frameRemains = 1.56 + 2 - frameDur * 0.75;  // most of one frame period left
              if (key_resp1_2.status === psychoJS.STARTED && t >= frameRemains) {
                key_resp1_2.status = psychoJS.STOPPED;
              if (key_resp1_2.status == psychoJS.STARTED) {
                theseKeys = psychoJS.event.getKeys({keyList:['y', 'n']});
                
                // check for quit:
                if ("escape" in theseKeys) {
                    endExpNow = true;
                }
                if (theseKeys.length > 0) {  // at least one key was pressed
                  key_resp1_2.keys = theseKeys[theseKeys.length-1]  // just the last key pressed
                  key_resp1_2.rt = key_resp1_2.clock.getTime();
                  // was this 'correct'?
                  if ((key_resp1_2.keys == psychoJS.str(corrAns)) || (key_resp1_2.keys == corrAns)) {
                      key_resp1_2.corr = 1;
                  } else {
                      key_resp1_2.corr = 0;
                  }
                  // a response ends the routine
                  continueRoutine = false;
                }
              }
              
              // *radicalprime* updates
              if (t >= 1.5 && radicalprime.status === psychoJS.NOT_STARTED) {
                // keep track of start time/frame for later
                radicalprime.tStart = t;  // (not accounting for frame time here)
                radicalprime.frameNStart = frameN;  // exact frame index
                radicalprime.setAutoDraw(true);
              }
              frameRemains = 1.5 + .06 - frameDur * 0.75;  // most of one frame period left
              if (radicalprime.status === psychoJS.STARTED && t >= frameRemains) {
                radicalprime.setAutoDraw(false);
              }
              
              // *targetchar* updates
              if (t >= 1.56 && targetchar.status === psychoJS.NOT_STARTED) {
                // keep track of start time/frame for later
                targetchar.tStart = t;  // (not accounting for frame time here)
                targetchar.frameNStart = frameN;  // exact frame index
                targetchar.setAutoDraw(true);
              }
              frameRemains = 1.56 + 2 - frameDur * 0.75;  // most of one frame period left
              if (targetchar.status === psychoJS.STARTED && t >= frameRemains) {
                targetchar.setAutoDraw(false);
              }
              
              // check if the Routine should terminate
              if (!continueRoutine) {  // a component has requested a forced-end of Routine
                return psychoJS.NEXT;
              }
              continueRoutine = false;// reverts to True if at least one component still running
              for(var i = 0; i < trial_1Components.length; ++i) {
                thisComponent = trial_1Components[i];
                if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
                  continueRoutine = true;
                  break;
                }
              }
              // check for quit (the Esc key)
              if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
                psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
              }
              
              // refresh the screen if continuing
              if (continueRoutine && routineTimer.getTime() > 0) {
                return psychoJS.FLIP_REPEAT;
              }
              else {
                return psychoJS.NEXT;
              }
            }
            
            function trial_1RoutineEnd() {
              //------Ending Routine 'trial_1'-------
              for (var i = 0; i < trial_1Components.length; ++i) {
                thisComponent = trial_1Components[i];
                if ("setAutoDraw" in thisComponent) {
                  thisComponent.setAutoDraw(false);
                }
              }
              // check responses
              if (['', [], undefined].indexOf(key_resp1_2.keys) >= 0) {    // No response was made
                  key_resp1_2.keys = undefined;
              }
              // was no response the correct answer?!
              if (key_resp1_2.keys == undefined) {
                if (psychoJS.str(corrAns).toLowerCase() == 'none') {
                   key_resp1_2.corr = 1  // correct non-response
                } else {
                   key_resp1_2.corr = 0  // failed to respond (incorrectly)
                }
              }
              // store data for thisExp (ExperimentHandler)
              thisExp.addData('key_resp1_2.keys',key_resp1_2.keys);
              thisExp.addData('key_resp1_2.corr', key_resp1_2.corr);
              if (key_resp1_2.keys != undefined) {  // we had a response
                  thisExp.addData('key_resp1_2.rt', key_resp1_2.rt)
              }
              return psychoJS.NEXT;
            }
            
            function registerResources() {
                psychoJS.resourceManager.scheduleRegistration(resourceScheduler);
            
                return psychoJS.NEXT;
            }
            
            function downloadResources() {
                psychoJS.resourceManager.scheduleDownload(resourceScheduler);
            
                return psychoJS.NEXT;
            }
            
            function trialsLoopBegin(thisScheduler) {
              // set up handler to look after randomisation of conditions etc
              try {
                trials = new psychoJS.data.TrialHandler({nReps:5, method:'random',
                  extraInfo:expInfo, originPath:undefined,
                  trialList:psychoJS.data.importConditions('stimuli.xlsx'),
                  seed:undefined, name:'trials'});
                thisExp.addLoop(trials); // add the loop to the experiment
                thisTrial = trials.trialList[trials.trialSequence[0]]; // so we can initialise stimuli with some values
                // abbreviate parameter names if possible (e.g. rgb=thisTrial.rgb)
                abbrevNames(thisTrial);
                // Schedule each of the trials in the list to occur
                for (var i = 0; i < trials.trialSequence.length; ++i) {
                  thisTrial = trials.trialList[trials.trialSequence[i]];
                  thisScheduler.add(abbrevNames(thisTrial));
                  thisScheduler.add(trial_1RoutineBegin);
                  thisScheduler.add(trial_1RoutineEachFrame);
                  thisScheduler.add(trial_1RoutineEnd);
                  thisScheduler.add(recordLoopIteration(trials));
                }
              } catch (exception) {
                console.log(exception);
              }
            
              return psychoJS.NEXT;
            }
            
            function trialsLoopEnd() {
              // get names of stimulus parameters
              if (psychoJS.isEmpty(trials.trialList)) { // XXX equiv of : in ([], [None], None)
                params = [];
              }
              else {
                params = Object.keys(trials.trialList[0]);
              }
            
              // save data for this loop
              thisExp.loopEnded(trials);
              return psychoJS.NEXT;
              }
            
            function run() {
              // init psychoJS and set up OpenGL Canvas
              setupWin();
              psychoJS.init(win);
              
              // main scheduler
              scheduler = new psychoJS.Scheduler();
              
              // Store info about the experiment session
              expName = 'stroop';  // from the Builder filename that created this script
              expInfo = {'participant':'', 'session':'01'};
              
              // set up experiment
              scheduler.add(setupExperiment);
              scheduler.add(psychoJS.setupCallbacks);
              
              // register all available resources and download them
              resourceScheduler = new psychoJS.Scheduler();
              resourceScheduler.add(registerResources);
              resourceScheduler.add(downloadResources);
              // asynchronous approach: the resource scheduler is run in parallel to the main one
              scheduler.add(function() { resourceScheduler.start(win); });
              
              // dialog box
              scheduler.add(psychoJS.gui.DlgFromDict({dictionary:expInfo, title:expName}));
              
              flowScheduler = new psychoJS.Scheduler();
              dialogCancelScheduler = new psychoJS.Scheduler();
              scheduler.addConditionalBranches(function() { return psychoJS.gui.dialogComponent.button === 'OK'; }, flowScheduler, dialogCancelScheduler);
              
              // flowScheduler gets run if the participants presses OK
              flowScheduler.add(updateInfo); // add timeStamp
              flowScheduler.add(experimentInit);
              flowScheduler.add(instructionsRoutineBegin);
              flowScheduler.add(instructionsRoutineEachFrame);
              flowScheduler.add(instructionsRoutineEnd);
              trialsLoopScheduler = new psychoJS.Scheduler();
              flowScheduler.add(trialsLoopBegin, trialsLoopScheduler);
              flowScheduler.add(trialsLoopScheduler);
              flowScheduler.add(trialsLoopEnd);
              flowScheduler.add(quitPsychoJS);
              
              // quit if user presses Cancel in dialog box:
              dialogCancelScheduler.add(quitPsychoJS);
              
              scheduler.start(win);
            }
            
            function abbrevNames(thisTrial) {
              return function () {
                // abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)
                if (thisTrial != undefined) {
                  for (paramName in thisTrial) {
                    window[paramName] = thisTrial[paramName];
                  }
                }
                return psychoJS.NEXT;
              };
            }
            
            function recordLoopIteration(currentLoop) {
              return function () {
                currentLoop.updateAttributesAtBegin();
                thisExp.nextEntry();
                return psychoJS.NEXT;
              }
            }
            
            function quitPsychoJS() {
                thisExp.save();
                win.close()
                psychoJS.core.quit();
                return psychoJS.QUIT;
            }

        run();
      });
    </script>

  </body>
</html>
